{"meta":{"title":"Grapeoni","subtitle":"","description":"To BGM","author":"Ms.xin","url":"http://grapeoni.xyz","root":"/"},"pages":[{"title":"标签","date":"2020-10-17T02:37:04.000Z","updated":"2020-10-17T08:29:22.990Z","comments":false,"path":"tags/index.html","permalink":"http://grapeoni.xyz/tags/index.html","excerpt":"","text":"test"},{"title":"分类","date":"2020-10-17T02:31:18.000Z","updated":"2020-10-17T08:13:53.482Z","comments":false,"path":"categories/index.html","permalink":"http://grapeoni.xyz/categories/index.html","excerpt":"","text":"算法"},{"title":"留言板","date":"2020-10-17T02:37:04.000Z","updated":"2020-10-17T02:50:45.290Z","comments":true,"path":"guestbook/index.html","permalink":"http://grapeoni.xyz/guestbook/index.html","excerpt":"","text":"欢迎来到枯燥站。"}],"posts":[{"title":"","slug":"线性时间选择","date":"2020-10-28T10:41:51.262Z","updated":"2020-10-28T10:43:40.341Z","comments":true,"path":"2020/10/28/线性时间选择/","link":"","permalink":"http://grapeoni.xyz/2020/10/28/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/","excerpt":"","text":"title: 线性时间选择author: Mrs.xintags: 随机选择算法 线性时间选择categories: [算法]date: 2020-10-28 18:44:00 线性时间选择一、题目给定线性集N个元素和一个整数， 1 &lt;= K &lt;= N, 要求找到第K个数。二、思考方向思路一：依次选择最大或者最小的数，重复此过程，直到找到第K个数。时间复杂度O(n^2);思路二：快排，堆排，归并效率可达到O(nlogn)思路三：堆排序，O(nlogn), 当K &lt;= n / logn 或 K &gt;= n - nlogn, 每一次heapify的时间为logn, K为元素个数，可以看到该方法对元素个数是有局限的，但确实我们找到了一条通往O(n)时间的路。思路四： 根据主定理来思考，T(n) = T(ε) + O(n), ( 0 &lt; ε &lt; 1 ), 如果能够找到ε，有这样的划分情况，那么在最坏情况下用O(n)的时间也可以实现。T(n) = O(n)。三、算法步骤1、将n个输入元素划分成[n/5]个组，每组5个元素，除可能有一个组不是5个元素外。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共有[n/5]个。2、递归调用Select找出这[n/5]个元素的中位数。如果[n/5]是偶数，就找它的两个中位数中较大的一个，然后以这个元素作为划分基准。代码展示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt;using namespace std;#define N 1000// 冒泡排序void bubbleSort(int a[], int p, int r) &#123; for(int i = p; i &lt; r - 1; i++) &#123; for(int j = p + 1; j &lt; r - i; j++) &#123; if(a[j] &lt; a[j-1] ) &#123; swap(a[j], a[j-1]); &#125; &#125; &#125;&#125; // 以x为基准的划分,返回划分的基准下标 int Partition(int a[], int p, int r, int x) &#123; int i = p - 1, j = r + 1; while(true)&#123; while(a[++i] &lt; x &amp;&amp; i &lt; r); while(a[--j] &gt; x &amp;&amp; j &gt; p); if(i &gt;= j ) break; swap(a[i], a[j]); &#125; return j;&#125; //找到中位数（用于找每组的5个数的中位数）int searchMid(int a[], int p, int r) &#123; int *b = new int[r - p + 1]; for (int i = p; i &lt;= r; ++i) &#123; b[i - p] = a[i]; &#125; bubbleSort(b, 0, r - p); for (int i = p; i &lt;= r; ++i) &#123; if (a[i] == b[(r - p + 1) / 2]) return i; &#125; return 0;&#125;//p第一个数下标，r最后一个数下标，k要找的第k个数int Select(int a[], int p, int r, int k) &#123; //规模小于75时直接排序查找 if (r - p &lt; 75) &#123; bubbleSort(a, p, r); return a[p + k - 1]; &#125; //分成n/5组，每组5个；找到每组中位数，放置队首 for (int i = 0; i &lt;= (r - p - 4) / 5; ++i) &#123; int mid = searchMid(a, p + 5 * i, p + 5 * i + 4); swap(a[mid], a[p + i]); &#125; //找到所有中位数的中位数 int x = Select(a, p, p + (r - p - 4) / 5, (r - p - 4 ) / 10 + 1); //按中位数划分 int i = Partition(a, p, r, x), j = i - p + 1; if (k &lt;= j)return Select(a, p, i, k); else return Select(a, i + 1, r, k - j);&#125;int main() &#123; unsigned seed; int n; cout &lt;&lt; &quot;输入一个随机种子: &quot;; cin &gt;&gt; seed; srand(seed); int a[N]; for(int i = 0; i &lt; N; i++)&#123; a[i] = rand(); &#125; cout &lt;&lt; &quot;选择第几大的数字：&quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;选择第&quot; &lt;&lt; n &lt;&lt; &quot;大的数字: &quot;; cout &lt;&lt; Select(a,0,N-1,n) &lt;&lt; endl; cout &lt;&lt; &quot;冒泡排序结果如下: &quot;; bubbleSort(a,0,N-1); for(int i = 0; i &lt; N; i++)&#123; if(i % 10 == 0) cout &lt;&lt; endl; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 四、算法理解 每组排序时间为线性时间，为了便于理解，这里记为5,一共是[n/5]组，所以总时间为O(n), 选择中位数的中位数。设对n个元素的数组调用Select需要T(n)的时间，那么找中位数的中位数x至多用T(n/5)的时间。现已证明，按照算法所选的基准x进行划分所得到的两个子数组分别至多有3n/4个元素。所以无论对哪一个子数组调用select都至多用T(3n/4)时间。​$$T(n) &lt;= T(n)\\leq\\begin{cases}C1&amp;n&lt;75\\C2n+T(n/5)+T(3n/4)&amp;n\\geq75\\end{cases}$$ 解此递归式，可得T(n) = O(n);","categories":[],"tags":[]},{"title":"test","slug":"第一篇博客","date":"2020-10-17T08:12:00.000Z","updated":"2020-10-17T08:29:54.093Z","comments":true,"path":"2020/10/17/第一篇博客/","link":"","permalink":"http://grapeoni.xyz/2020/10/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"admin_test","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://grapeoni.xyz/tags/test/"}],"author":"Mrs.xin"}],"categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://grapeoni.xyz/tags/test/"}]}